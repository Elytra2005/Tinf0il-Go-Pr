(() => { "use strict"; const e = async () => { (await chrome.runtime.getContexts({})).find((e => "OFFSCREEN_DOCUMENT" === e.contextType)) || await chrome.offscreen.createDocument({ url: "offscreen.html", reasons: ["USER_MEDIA"], justification: "Recording from chrome.tabCapture API and accessing the HTML Canvas" }) }, t = () => { let e = document.createElement("style"); document.head.appendChild(e), e.type = "text/css", e.innerText = "\n        * {\n            -webkit-user-select: text !important;\n            -moz-user-select: text !important;\n            -ms-user-select: text !important;\n            user-select: text !important;\n        }\n    "; function t() { this.events = ["DOMAttrModified", "DOMNodeInserted", "DOMNodeRemoved", "DOMCharacterDataModified", "DOMSubtreeModified"], this.bind() } function n(e) { this.event = e, this.contextmenuEvent = this.createEvent(this.event.type) } ["contextmenu", "copy", "cut", "paste", "mouseup", "mousedown", "keyup", "keydown", "drag", "dragstart", "select", "selectstart"].forEach((e => { document.addEventListener(e, (e => { e.stopPropagation() }), !0) })), setTimeout((() => { document.oncontextmenu = null }), 2e3), ["copy", "cut", "paste", "select", "selectstart"].forEach((e => { document.addEventListener(e, (e => { e.stopPropagation() }), !0) })), window.addEventListener("contextmenu", (function e(a) { a.stopPropagation(), a.stopImmediatePropagation(); let o = new n(a); window.removeEventListener(a.type, e, !0); let r = new t; o.fire(), window.addEventListener(a.type, e, !0), o.isCanceled && r.isCalled && a.preventDefault() }), !0), t.prototype.bind = function () { this.events.forEach((e => { document.addEventListener(e, this, !0) })) }, t.prototype.handleEvent = function () { this.isCalled = !0 }, n.prototype.createEvent = function (e) { let t = this.event.target, n = t.ownerDocument.createEvent("MouseEvents"); return n.initMouseEvent(e, this.event.bubbles, this.event.cancelable, t.ownerDocument.defaultView, this.event.detail, this.event.screenX, this.event.screenY, this.event.clientX, this.event.clientY, this.event.ctrlKey, this.event.altKey, this.event.shiftKey, this.event.metaKey, this.event.button, this.event.relatedTarget), n }, n.prototype.fire = function () { this.event.target.dispatchEvent(this.contextmenuEvent), this.isCanceled = this.contextmenuEvent.defaultPrevented }, function () { let e = document.createElement("style"); document.head.appendChild(e), e.type = "text/css", e.innerText = "\n            * {\n                -webkit-user-select: text !important;\n                -moz-user-select: text !important;\n                -ms-user-select: text !important;\n                user-select: text !important;\n            }\n        "; let t = document.querySelectorAll("*"); for (let e = 0; e < t.length; e++)"none" === t[e].style.userSelect && (t[e].style.userSelect = "auto");[document, document.body].forEach((e => { ["oncontextmenu", "onselectstart", "ondragstart", "onmousedown", "oncut", "oncopy", "onpaste"].forEach((t => { e[t] = null })) })) }() }, n = e => { chrome.scripting.executeScript({ target: { tabId: e, allFrames: !0 }, func: t }) }, a = async e => { try { const t = await fetch(e), n = await t.blob(); return new Promise(((e, t) => { const a = new FileReader; a.onload = function (t) { const n = t.target.result; e(n) }, a.onerror = function (e) { t(e.message || e) }, a.readAsDataURL(n) })) } catch (e) { return e.message || e } }, o = e => { let t = new URL(e).pathname.split("/").pop(); return t = decodeURIComponent(t), t = t.replace(/[^\w\-.,@ ]+/g, ""), t }; chrome.runtime.onMessage.addListener((async t => { var n, a; "background" === t.target && ("setTabVolume" === t.name ? await (async (t, n) => { if (await e(), (await chrome.tabCapture.getCapturedTabs()).some((e => e.tabId === t))) chrome.runtime.sendMessage({ name: "setVolume", target: "offscreen", tabId: t, value: n }); else { const e = await chrome.tabCapture.getMediaStreamId({ targetTabId: t }); await chrome.runtime.sendMessage({ name: "startRecording", target: "offscreen", streamId: e, tabId: t, value: n }) } })(t.tabId, t.value) : "updateVolume" === t.name ? chrome.storage.local.set({ [String(t.tabId)]: t.value }) : "disposeTab" === t.name ? chrome.storage.local.remove(String(t.tabId)) : "downloadImage" === t.name && (n = t.dataUrl, a = t.filename, chrome.downloads.download({ url: n, filename: a, saveAs: !0 }))) })), chrome.tabs.onRemoved.addListener((e => { chrome.runtime.sendMessage({ name: "disposeTab", target: "offscreen", tabId: e }) })), chrome.runtime.onInstalled.addListener((() => { chrome.storage.local.get(["saveImageAsType"], (e => { e.saveImageAsType && (chrome.contextMenus.create({ id: "parent", title: "Save as type", contexts: ["image"] }), chrome.contextMenus.create({ id: "jpg", title: "JPG", parentId: "parent", contexts: ["image"] }), chrome.contextMenus.create({ id: "png", title: "PNG", parentId: "parent", contexts: ["image"] }), chrome.contextMenus.create({ id: "webp", title: "WebP", parentId: "parent", contexts: ["image"] })) })) })), chrome.contextMenus.onClicked.addListener((async t => { const n = await a(t.srcUrl), r = o(t.srcUrl); await e(), await chrome.runtime.sendMessage({ name: "convertType", target: "offscreen", dataUrl: n, filename: r, imageFormat: t.menuItemId }) })); const r = e => { chrome.storage.local.get(["userAgentValue", "enableRightClick"], (t => { var a, o; t.userAgentValue && (a = e.tabId, o = t.userAgentValue, chrome.scripting.executeScript({ target: { tabId: a, allFrames: !0 }, world: "MAIN", injectImmediately: !0, func: e => { Object.defineProperty(window.navigator, "userAgent", { value: e, configurable: !0 }), Object.defineProperty(window.navigator, "appVersion", { value: e, configurable: !0 }), Object.defineProperty(window.navigator, "userAgentData", { value: void 0, configurable: !0 }) }, args: [o] })), t.enableRightClick && n(e.tabId) })) }; chrome.webNavigation.onCommitted.addListener(r), chrome.webNavigation.onHistoryStateUpdated.addListener(r) })();